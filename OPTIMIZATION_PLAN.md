# 블로그 빌드 성능 최적화 계획

## 목표
기존 기능을 유지하면서 빌드 시간과 런타임 성능을 크게 개선

## 현재 문제점 요약
1. 모든 포스트의 HTML을 하나의 거대한 JSON에 포함
2. 클라이언트에서 불필요하게 전체 포스트 데이터 로드
3. 빌드 시 모든 포스트를 동시에 메모리에 로드
4. 언어별 중복 처리
5. 이미지 전체 재복사

## 최적화 방안

### 1. 데이터 구조 분리 (핵심 개선)
**목표**: 메타데이터와 HTML 콘텐츠 분리

**구조 변경**:
```
public/posts-data/
  ├── en-metadata.json      # 메타데이터만 (목록용, 작은 크기)
  ├── ko-metadata.json
  └── content/              # 개별 포스트 HTML
      ├── en/
      │   ├── 2025-12-29-amr-2025q3-analysis.json
      │   └── ...
      └── ko/
          ├── 2025-12-29-amr-2025q3-analysis.json
          └── ...
```

**효과**:
- 목록 페이지: 메타데이터만 로드 (크기 90% 감소)
- 상세 페이지: 필요한 포스트만 로드 (지연 로딩)
- 빌드 시간: HTML 변환을 개별 파일로 분산 저장

### 2. 지연 로딩 (Lazy Loading)
**목표**: 필요한 포스트의 HTML만 로드

**변경사항**:
- `PostsList`: 메타데이터만 사용 (기존 동작 유지)
- `BlogPostContent`: 초기 렌더링은 빌드된 HTML 사용, 언어 변경 시 개별 JSON 로드

**효과**:
- 초기 로딩 시간 단축
- 메모리 사용량 감소
- 네트워크 트래픽 감소

### 3. 빌드 프로세스 최적화
**목표**: 빌드 시간 단축

**개선사항**:
- 비동기 파일 처리 (fs.promises 사용)
- 배치 처리 (동시 처리 수 제한)
- 공통 로직 통합 (중복 제거)
- 증분 이미지 복사 (변경된 파일만)

**효과**:
- 빌드 시간 50-70% 단축 예상
- 메모리 사용량 안정화

### 4. 캐싱 전략
**목표**: 반복 빌드 시간 단축

**구현**:
- 포스트 파일의 수정 시간 추적
- 변경된 포스트만 재처리
- 이미지 해시 비교

**효과**:
- 증분 빌드 시 시간 80-90% 단축

## 구현 계획

### Phase 1: 데이터 구조 분리 (우선순위: 높음)
**예상 시간**: 2-3시간
**영향도**: 매우 높음

1. **새로운 JSON 생성 스크립트 작성**
   - `generate-posts-metadata.js`: 메타데이터만 추출
   - `generate-posts-content.js`: 개별 HTML 파일 생성
   - 기존 `generate-posts-json.js` 리팩토링

2. **클라이언트 코드 수정**
   - `PostsList.tsx`: 메타데이터 JSON만 로드
   - `BlogPostContent.tsx`: 개별 포스트 JSON 로드
   - 하위 호환성 유지 (기존 JSON도 지원)

3. **테스트**
   - 빌드 테스트
   - 언어 전환 테스트
   - 포스트 목록/상세 페이지 테스트

### Phase 2: 빌드 프로세스 최적화 (우선순위: 중간)
**예상 시간**: 1-2시간
**영향도**: 중간

1. **비동기 처리로 전환**
   - `fs.readFileSync` → `fs.promises.readFile`
   - `fs.existsSync` → `fs.promises.access`
   - `fs.writeFileSync` → `fs.promises.writeFile`

2. **배치 처리 구현**
   - 동시 처리 수 제한 (예: 10개씩)
   - Promise.all 대신 p-limit 사용

3. **공통 로직 통합**
   - `posts.ts`와 `generate-posts-json.js` 공통 모듈화
   - 중복 코드 제거

### Phase 3: 이미지 최적화 (우선순위: 낮음)
**예상 시간**: 30분-1시간
**영향도**: 낮음

1. **증분 복사 구현**
   - 파일 해시 비교
   - 변경된 이미지만 복사

### Phase 4: 증분 빌드 (선택사항, 향후)
**예상 시간**: 2-3시간
**영향도**: 높음 (반복 빌드 시)

1. **캐시 메커니즘**
   - 포스트 파일 수정 시간 추적
   - 변경 감지 로직

## 예상 성능 개선

### 빌드 시간
- 현재 (4개): ~5-10초
- 최적화 후 (4개): ~3-5초
- 최적화 후 (100개): ~15-30초 (기존: 1-2분)
- 최적화 후 (1000개): ~2-5분 (기존: 10-30분)

### 런타임 성능
- 목록 페이지 로딩: 90% 감소
- 상세 페이지 로딩: 50% 감소 (초기), 80% 감소 (언어 전환 시)
- 메모리 사용량: 70% 감소

### 파일 크기
- 메타데이터 JSON: 포스트당 ~1-2KB (기존: 10-50KB)
- 개별 HTML JSON: 필요 시에만 로드

## 하위 호환성
- 기존 API 인터페이스 유지
- 점진적 마이그레이션 가능
- 기존 JSON 파일도 지원 (fallback)

## 리스크 및 대응
1. **리스크**: 클라이언트 코드 변경으로 인한 버그
   - **대응**: 철저한 테스트, 하위 호환성 유지

2. **리스크**: 빌드 스크립트 복잡도 증가
   - **대응**: 명확한 모듈 분리, 문서화

3. **리스크**: GitHub Pages 배포 시 파일 수 증가
   - **대응**: 파일 수는 증가하지만 전체 크기는 감소, GitHub 제한 내

## 구현 순서
1. Phase 1 완료 → 테스트 → 배포
2. Phase 2 완료 → 테스트 → 배포
3. Phase 3 완료 → 테스트 → 배포
4. Phase 4는 필요 시 구현

